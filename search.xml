<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[期望(例题+讲解)]]></title>
    <url>%2F2019%2F10%2F08%2F%E6%9C%9F%E6%9C%9B-%E4%BE%8B%E9%A2%98-%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1. 前言数学期望当前在OI中是一个类似于数论方面门槛的知识，在竞赛中有考察。本文将详细的讲解此内容，但也不是只纠缠于简单的概念，而会解决一些题目. 2. 什么是期望日常生活中，我们每做一件事，都有对它的期望，这里的期望不仅仅只结果的胜负之类，也可以与状态有关。但在OI中，一般指的就是达到结果的期望，最朴素的计算是 每次可能结果的概率乘以其结果的总和 这是最基本的数学特征。 广义下的定义：一次随机抽样中所期望的某随机变量的取值 数学定义： 3. 期望的小性质设 X 是随机变量，C是常数，则 E(CX) = C * E(X) 简单证明一下： 设 x 的多个随机变量为$$C_{a_1},C_{a_2},C_{a_3}…C_{a_n}$$对应的出现概率为$$p_1,p_2,p_3…p_n$$那么对应的求期望的式子$$E(CX)=C\sum_{i=1}^{n}(a_ip_i)$$*由于**$$E(X) = \sum_{i=1}^{n}(a_ip_i)$$*所以**$$E(CX) = C * E(X)$$下面的可以自行思考，都不难 设X, Y是任意两个随机变量,则有 E(X+Y) = E(X) + E(Y) 设X, Y是相互独立的随机变量,则有 E(XY) = E(X) * E(Y) 设 c 为常数,则E(C) = C 4. 期望与均值期望与均值是两个十分相近的概念，但又可以说是截然不同。 均值往往是在实验中简单的对数据进行平均。 而期望就好像在上帝视角的人。 举个骰子的例子: 我们的均值怎么算呢 ? 显然要掷上一定多的次数来求平均数 比如, 掷了 6 次, 分别为 1, 5, 5, 6, 3, 3，那么均值为$$\frac{1+5+5+6+3+3}{6}=3.833333…$$可是期望呢 ? 我们不用掷骰子就能计算出来: 可以看出，两个值是有明显差别的，而且还时刻不同。 但是为什么容易弄混呢？ 因为我太弱了在将多个均值求均值后，两者就无限接近了。 5. 引入1. 问题1甲乙两个正常人赌博，丙作为裁判监督，五局三胜，赢家可以获得100元的奖励。当比赛进行到第四局的时候，甲胜了两局，乙胜了一局，但这时赌场遇到了警察的查封，丙见势不妙，立马逃走了，甲乙两人被迫中止了比赛，那么，如何分配这100元？（每局都能分出胜负） 方案1: 每人50元 这显然是和平解决问题的方式，此时乙会赞成，但是甲一定有意见，显然，自己已经拿下赛点，不可能心甘情愿的平均分钱。 方案2: 按照获胜的概率分 假设比赛继续进行，那么下一轮： 50%: 甲赢，拿下100元 50%：乙赢，继续比赛 但是，如果问题就进行到这里，也就没有接下来的期望了 再次观察。 假设甲最终输了，那么他是在什么概率下输的呢？$$\frac{1}{2}\frac{1}{2}=\frac{1}{4}$$*他实际上只有四分之一的概率输。** 显而易见，因为每局都能分出胜负，所以他有四分之三的概率赢掉。 那么情况就简单了，我们根据他们的胜率来分钱。$$甲分:100*\frac{3}{4}=75元$$ $$乙分:100*\frac{1}{4}=25元$$ 此游戏完结 2. 问题2一位公司招募员工，几乎没有什么面试，甲乙两个年轻人就意外的获得了一份工作，这时，面试官却说要给他们发入司奖金，每人需要从各自的三个红包中选择一个。 此时，他们已知红包中有一个1000元的，两个500元的。 两位年轻人各自抽取了一个。 他们刚要打开红包，面试官却制止了他们，随机打开每人剩下红包中的一个，相同的，里面都装着500元钱。 于是面试官向他们询问：如果同意你们用手上的红包换取未打开的红包，你会换吗？ 乍一看，这是一个无厘头的问题，可能有些意气风发的人便想到坚持自我等诸多大道理，或者暗自猜测面试官在红包上做了什么标记。 但也有些人想把握机会。 凑巧，甲坚持了原来的选择，乙却尝试了机会。 表面上看，这是一个完全机会均等，拼手气的选择。 但真的是这样吗？ 稍加理性分析，我们可以得到一个初步的结论，帮助我们做出选择： 如果员工刚开始恰巧选择了1000元，他不交换会得到1000元，而显然有更大概率他刚开始选到了500元，那么他相应的就只能得到500元了。 由此，选择交换会获得更大的收益。 当然，我们可以不仅仅停留在定向判断。 下面定量计算一下： 设为A，B，C三个红包$$当员工选择了A红包后,就将三个红包分为两组,第一组为A红包,第二组为B、C红包$$ $$很明显1000元在第一组的概率为\frac{1}{3},在第二组的概率为\frac{2}{3},而面试官打开了B红包,$$ $$发现B为500元红包,这里其实是帮助员工在第二组里筛选掉了一个错误答案,$$ $$所以1000元在C红包的概率其实为\frac{2}{3}$$ 所以就要换喽 但是，当甲走到门口时，面试官灵机一动，告诉他可以再回答一个问题。 于是甲满怀激动地走了过来。 面试官把向两人踢出提出了下一个问题： 如果给你手上的红包，让你换已经打开的呢？（打开的那个是500元） 显然无论如何都是不换的于是两人完美的成为了同事 面试官因招到了人完美的收到了4000元 这其实是一个著名的三门问题，也称为蒙提霍尔问题、蒙特霍问题或蒙提霍尔悖论，这个问题因在数学逻辑推理上合理，但违背直觉而闻名于世 6. 期望的应用彩票问题 在买彩票中，大多数人相信基本上是没法中奖的，但还是有少数人幻想，于是就再这里简要分析一个彩票问题的期望. 设一张彩票为2元，每售1000000 10000001000000张开奖，假设中奖号码为342356 342356342356，则每张彩票有一个对应的六位数号码，奖次如下：（中奖不叠加） 末位相等,安慰奖：奖励4元，中奖概率0.1 后两位相等,幸运奖：奖励20元，中奖概率0.01 后三位相等,手气奖：奖励200元，中奖概率0.001 后四位相等,一等奖：奖励2000元，中奖概率0.0001 后五位相等,特等奖：奖励20000元，中奖概率0.00001 某大佬：咦我六位都相等，快给我200000元！！！ 彩票公司:你没看你这一项没有吗？你只是特等奖（我是不会告诉你再给钱就亏了 那到底为什么亏了呢 我们来用简单的概率知识来计算一下，对于每一位购买彩票的用户，公司可能支出为：$$0.14+0.0120+0.001200+0.00012000+0.0000120000=1.2$$*也就是说，公司期望对每个人赚0.8元。** 每1000000张，就是800000元！ 回到刚才大佬的疑问，显然，如果按照开奖规律继续的话，公司会少赚200000元！！ 这显然是一笔不小的损失 彩票公司：我这怎么给员工发工资？！ 由此可见，彩票公司售卖彩票会让买家有惊现不同的体验（奖次不同），但即使是随机生成彩票号码，卖得多了所支出的钱一定在期望值附近，而能保证稳定的收入，而且彩票单价低，还有可能中那么多奖，买的人多，这样彩票市场才得以持续下去。 7. 例题时间1. 洛谷 P1654 (高次期望 + 递推)传送门 首先给出期望的关系:$$E((x+1)^3) = E(x^3) + 3E(x^2) + 3E(x) + 1$$ $$E((x + 1)^2) = E(x^2) + 2E(x) + 1$$ $$E(x+1) = E(x) + 1$$ 这里我们要知道:$$E(x^2) - E((x-1)^2) = 2E(x-1) + 1$$故对于二次来说:$$由 E((x-1)^2)到E(x^2)只需加2E(x-1)+1$$ $$在这里我们称:由 E((x-1)^2)到E(x^2)所做的贡献是2E(x-1)+1$$ 123期望是线性的平方的期望和立方的期望不是线性的 然后我们定义: 1234567x1[i]:表示算到第i位前面所有极长的连续为1的子串长度的之和的期望x2[i]:表示算到第i位前面所有极长的连续为1的子串长度的平方之和的期望x3[i]:表示算到第i位前面所有极长的连续为1的子串长度的立方之和的期望p[i]:表示第i个操作的成功率 对于 一次 来说 $$x_1[i] = (x_1[i - 1] + 1) * p[i]$$ 这里注意:$$+1: 第i位为1时对期望所做的贡献(加1)$$ $$p[i]:有p[i]的概率第i位为1$$ 故乘p[i] 对于 二次 来说 $$x_2[i] = (x_2[i - 1] + 2x_1[i - 1] + 1) * p[i]$$ 注意:$$2x_1[i-1]+1:第i位为1时对期望所做的贡献$$ $$p[i]:有p[i]的概率第i位为1$$ 对于 三次 来说 $$x_3[i] = (x_3[i - 1] + 3x_2[i - 1] + 3x_1[i - 1] + 1) * p[i]$$ 注意:$$3x_2[i - 1] + 3x_1[i - 1] + 1:第i位为1时对期望所做的贡献$$ $$p[i]:有p[i]的概率第i位为1$$ 到这里我们分析完毕,但前三个式子我们都只考虑 第i位，这样做是为了递推下面的式子，但是答案让我们求出最终的期望分数，也就是 前n位 所以我们还需做一点变形 :$$x_3[i] = (x_3[i - 1] + 3x_2[i - 1] + 3x_1[i - 1] + 1) * p[i] + x_3[i - 1] * (1 - p[i])$$ $$=x_3[i - 1] + (3x_2[i - 1] + 3x_1[i - 1] + 1) * p[i]$$ 注意:$$1-p[i]:第i位为0的概率$$ $$前i位的期望分数=第i位为1时的期望分数+第i位为0时的期望分数 (递推关系)$$ 代码实现:123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int n;double p[100005], x1[100005], x2[100005], x3[100005];int main() &#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; p[i]; &#125; for(int i = 1; i &lt;= n; i++) &#123; x1[i] = (x1[i - 1] + 1) * p[i]; x2[i] = (x2[i - 1] + 2 * x1[i - 1] + 1) * p[i]; x3[i] = x3[i - 1] + (3 * x2[i - 1] + 3 * x1[i - 1] + 1) * p[i]; &#125; printf("%.1lf\n", x3[n]); return 0;&#125; 2. 洛谷 UVA10288 (低次期望 + 递推)传送门$$设Y为集齐n种奖需要买的彩票数量$$ $$设 Y_{k} 为已获得 k 种奖后，想收集到第 k+1 种奖需要买的彩票数量$$ $$可得 Y=Y_{0}+Y_{1}+Y_{2}+…+Y_{n-1}$$ 由期望的线性：$$E(Y)=E(Y_{0}+Y_{1}+Y_{2}+…+Y_{n-1})=E(Y_{0})+E(Y_{1})+E(Y_{2})…+E(Y_{n-1})$$ $$因为获得k种奖后，再想获得第k+1种奖的概率为 \frac{n-k}{n}$$ $$设对立面不能获得第k+1种奖的概率为 p=\frac{k}{n}$$ 能否获得是互相对立的（条件概率），所以要获得第k+1奖所需买的彩票数可能为 1~m（m为无穷大，可能运气差一直开不到）$$得 收集到第k+1张彩票需要买 t 张彩票的概率为 P_{t}=p^{t-1}*(1-p)$$ $$所以 Y_{k} 的期望为：E(Y_{k})=\sum_{t=1}^{n}t*P_{t}=(1-p)(1+2p+3p^{2}+…+mp^{m-1})$$ $$所以pE(Y_{k})=\sum_{t=1}^{n}tP_{t}=(1-p)(p+2p^{2}+3p^3+…+mp^{m})$$ $$两式错位相减得:E(Y_k) =1+p+p^2+p^3+…+p^{m-1}-mp^m$$ $$根据等比数列求和得: E(Y_{k})=\frac{1-p^{m}}{1-p}-mp^{m}$$ $$=\frac{1}{1-p}-(\frac{p^{m}}{1-p}+mp^{m})$$ $$=\frac{1}{1-p}-(\frac{1}{1-p}+m)*p^m$$ $$因为m无穷大,故当m为\frac{-1}{1-p}时,E(Y_k)最大$$ $$此时E(Y_k) = \frac{1}{1-p} = \frac{n}{n-k}$$ $$故E(Y) =\sum_{k=0}^{n-1} \frac{n}{n-k} = n\sum_{k=1}^{n} \frac{1}{k}$$ 代码实现:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;int N;ll A[35] = &#123;0, 1&#125;, B[35] = &#123;0, 1&#125;; // A[i]: 前i项和的分子 B[i]:前i项和的分母// B[1] 需要预处理，否则无法计算ll gcd(ll a, ll b) &#123; if(b == 0) return a; return gcd(b, a % b);&#125;inline void Red(ll &amp;m, ll &amp;n) &#123; ll d = gcd(m, n); m /= d; n /= d;&#125;inline void init() &#123; for(ll i = 2, a, b; i &lt;= 33; ++i) &#123; a = A[i - 1], b = B[i - 1]; A[i] = (ll)a * i + b; B[i] = (ll)b * i; Red(A[i], B[i]); &#125;&#125;inline int Len(ll n) &#123; int ans = 0; while(n != 0) &#123; ans++; n /= 10; &#125; return ans;&#125;int main() &#123; init(); while(cin &gt;&gt; N) &#123; ll a = A[N] * N, b = B[N]; Red(a, b); // 由于乘了一个 N，需要再次约分 if(b == 1) &#123; // 如果能整除，直接特判，不需输出分数 cout &lt;&lt; a &lt;&lt; endl; continue; &#125; ll k = a / b; // k 为带分数的整数部分 a -= k * b; int lb = Len(b), lk = Len(k); // 以下分别输出带分数的三行 for(int i = 1; i &lt;= lk + 1; i++) &#123; cout &lt;&lt; ' '; &#125; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; k &lt;&lt; ' '; for(int i = 1; i &lt;= lb; i++) &#123; cout &lt;&lt; '-'; &#125; cout &lt;&lt; endl; for(int i = 1; i &lt;= lk + 1; i++) &#123; cout &lt;&lt; ' '; &#125; cout &lt;&lt; b &lt;&lt; endl; &#125; return 0;&#125; 3. 洛谷 P4550 (高次期望 + 递推)传送门 这道题是第二题的升级版，要用到高次的期望，但输出不用那么麻烦了 首先第一步很好转化吧，设用了x步，则花费为$$ans =\sum_{i=1}^{x}i =\frac {(x^2+x)}{2}$$现在就转换成要求上式的期望 有了前面那题的基础现在考虑起来就简单了 维护一个线性期望 x1，平方期望 x2（都是数组） 好吧再清楚地表达一下：$$x_1[i]:表示找完i个数之后还需要的次数的期望$$ $$x_2[i]:表示找完i个数之后还需要的次数平方的期望$$ $$不难想到最后的答案是\frac{x_1[0]+x_2[0]}{2}$$ 下面就开始考虑状态转移（dp？） 1. 先来考虑 x1[i]$$x_1[i] = ?$$ $$边界x_1[n]=0我们都知道,而我们要求的是x_1[0]$$ $$显然,需要倒推$$ 情况1: 买到买过的$$买过的是i个,概率为\frac{i}{n},花费就相当于记在买到i时候的账上了(从i账上查),$$ $$得到花费为x_1[i]+1(贡献为1,这里的1为步数)$$ $$故可得到式子:\frac{i}{n}(x_1[i]+1)$$ 情况2:买到没买过的$$没买过的是n-i个,概率为\frac{n-i}{n},花费就相当于记在买到i+1时候的$$ $$账上了(从i+1账上查),因为当前多买了一个,得到的花费为x_1[i+1]+1(贡献为1)$$ $$故可得到式子:\frac{n-i}{n}(x_1[i+1]+1)$$ 两种情况合并,得:$$x_1[i] = \frac{i}{n}(x_1[i]+1)+\frac{n-i}{n}x_1[i+1]+1)$$一顿骚操作(正常化简),得:$$x_1[i] = x_1[i+1]+\frac{n}{n-i}$$2. 再考虑x2[i] 唉有了前面osu的铺垫这还不是轻而易举 ? 跟推 x1 的时候一个思路，新的或旧的，唯一就把平方拆开就行喽$$边界x_2[n]=0,故可得式子:$$ $$x_2[i] = \frac{i}{n}(x_2[i] + 2x_1[i] + 1) + \frac{n-i}{n}(x_2[i+1]+2x_1[i+1]+1)$$ OK既然上面讲了写式子下面就说说化简的事吧~$$把第一个括号拆成x_2[i]和2x_1[i]+1两部分$$ $$然后把\frac{i}{n}*x_2[i]给移到左边,合并得:$$ $$\frac{n-i}{n}x_2[i]=\frac{i}{n}(2x_1[i]+1)+\frac{n-i}{n}{x_2[i+1]+2x_1[i+1]+1}$$ $$两边同除\frac{n-i}{n},得:$$ $$x_2[i]=\frac{i}{n-i}(2x_1[i]+1)+x_2[i+1]+2x_1[i+1]+1$$ 这样就会简单一些了 代码实现:1234567891011121314151617#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int n;double x1[10005], x2[10005];int main() &#123; cin &gt;&gt; n; for(int i = n - 1; i &gt;= 0; i--) &#123; x1[i] = x1[i + 1] + 1.0 * n / (n - i); x2[i] = 1.0 * i / (n - i) * (2 * x1[i] + 1) + x2[i + 1] + 2 * x1[i + 1] + 1; &#125; printf("%.2lf\n", (x1[0] + x2[0]) / 2); return 0;&#125; 4. 参考网址传送门1 传送门2]]></content>
      <tags>
        <tag>In the story of your life, don’t let anybody else hold the pen. 不要让他人执笔，来书写你的生命故事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字典树 (Trie 树)]]></title>
    <url>%2F2019%2F09%2F11%2F%E5%AD%97%E5%85%B8%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1. 引入字典是干啥的？查找字的。 字典树自然也是起查找作用的。查找的是啥？单词。 看以下几个题： 1) 给出n个单词和m个询问，每次询问一个单词，回答这个单词是否在单词表中出现过。 答：简单！map，短小精悍。 好。下一个 2) 给出n个单词和m个询问，每次询问一个前缀，回答询问是多少个单词的前缀。 答：map，把每个单词拆开。 judge：n&lt;=200000，TLE！ 这就需要一种高级数据结构——Trie树（字典树） 2. 原理在本篇文章中，假设 所有单词都只由小写字母 构成 对cat，cash，app，apple，aply，ok 建一颗字典树，建成之后如下图所示 由此可以看出： 1、字典树用边表示字母 2、有相同前缀的单词公用前缀节点，那我们可以的得出每个节点最多有26个子节点（在单词只包含小写字母的情况下） 3、整棵树的根节点是空的。为什么呢？便于插入和查找，这将会在后面解释。 4、每个单词结束的时候用一个特殊字符表示，图中用的‘′，那么从根节点到任意一个‘′，那么从根节点到任意一个‘’所经过的边的所有字母表示一个单词。 3. 基本操作1. insert 插入一个单词思路: 从图中可以直观看出，从左到右扫这个单词，如果字母在相应根节点下没有出现过，就插入这个字母；否则沿着字典树往下走，看单词的下一个字母。 这就产生一个问题：往哪儿插？计算机不会自己选择位置插，我们需要给它指定一个位置，那就需要给每个字母编号。 我们设数组trie[i][j]=k，表示编号为i的节点的第j个孩子是编号为k的节点。 什么意思呢？ 这里有2种编号，一种是i，k表示节点的位置编号，这是相对整棵树而言的；另一种是j，表示节点i的第j的孩子，这是相对节点i而言的。 不理解？看图 还是单词cat，cash，app，apple，aply，ok 我们就按输入顺序对其编第一种号，红色表示编号结果。因为先输入的cat，所以c，a，t分别是1,2,3，然后输入的是cash，因为c，a是公共前缀，所以从s开始编，s是4，以此类推。 注意这里相同字母的编号可能不同 第二种编号，相对节点的编号，紫色表示编号结果。 因为每个节点最多有26个子节点，我们可以按他们的字典序从0——25编号，也就是他们的ASCLL码-a的ASCLL码。 注意这里相同字母的编号相同 实际上每个节点的子节点都应该从0编到——25，但这样会发现许多事根本用不到的。比如上图的根节点应该分出26个叉。节约空间，用到哪个分哪个。 这样编号有什么用呢？ 回到数组trie[i][j]=k。 数组trie[i][j]=k，表示编号为i的节点的第j个孩子是编号为k的节点。 那么第二种编号即为j，第一种编号即为i，k 代码实现: 12345678910void insert() &#123; //插入单词s len = strlen(s); //单词s的长度 root = 0; //根节点编号为0 for(int i = 0; i &lt; len; i++) &#123; int id = s[i] - 'a'; //第二种编号 if(!trie[root][id]) //如果之前没有从root到id的前缀 trie[root][id] = ++tot; //插入，tot即为第一种编号 root = trie[root][id]; //顺着字典树往下走 &#125;&#125; 2. search 查找思路: 从左往右以此扫描每个字母，顺着字典树往下找，能找到这个字母，往下走，否则结束查找，即没有这个前缀；前缀扫完了，表示有这个前缀。 代码实现: 1234567891011bool find() &#123; len = strlen(s); root = 0; //从根结点开始找 for(int i = 0; s[i]; i++) &#123; int x = s[i] - 'a';// if(trie[root][x] == 0) return false; //以root为头结点的x字母不存在，返回0 root = trie[root][x]; //为查询下个字母做准备，往下走 &#125; return true;//找到了&#125; 3、如果是查询某个单词的话，我们用bool变量 v[i]表示节点i是否是单词结束的标志。 ​ 那么最后return的是v[root],所以在插入操作中插入完每个单词是，要对单词最后一个字母的v[i]置为true，其他的都是false 4、如果是查询前缀出现的次数的话，那就在开一个sum[]，表示位置i被访问过的次数 那么最后return的是sum[root]，插入操作中每访问一个节点，都要让他的sum++ 这里前缀的次数是标记在前缀的最后一个字母所在位置的后一个位置上。 比如:前缀abc出现的次数标记在c所在位置的后一个位置上 3. 完整代码实现1. 查询是否出现 (前缀 或 全部) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* trie tree的储存方式：将字母储存在边上，边的节点连接与它相连的字母 trie[rt][x]=tot:rt是上个节点编号，x是字母，tot是下个节点编号 */ #include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define maxn 2000010using namespace std;int tot = 1, n;int trie[maxn][26];//bool isw[maxn];查询整个单词用void insert(char *s, int rt) &#123; for(int i = 0; s[i]; i++) &#123; int x = s[i] - 'a'; if(trie[rt][x] == 0) &#123; //现在插入的字母在之前同一节点处未出现过 trie[rt][x] = ++tot;//字母插入一个新的位置，否则不做处理 &#125; rt = trie[rt][x];//为下个字母的插入做准备 &#125; /*isw[rt] = true;标志该单词末位字母的尾结点，在查询整个单词时用到*/&#125;bool find(char *s, int rt) &#123; for(int i = 0; s[i]; i++) &#123; int x = s[i] - 'a'; if(trie[rt][x] == 0) return false; //以rt为头结点的x字母不存在，返回0 rt = trie[rt][x]; //为查询下个字母做准备 &#125; return true; //查询整个单词时，应该return isw[rt] &#125;char s[22];int main() &#123; tot = 0; int rt = 0; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; s; insert(s, rt); &#125; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; s; if(find(s, rt)) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; 2. 查询前缀出现次数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int trie[400001][26], len, root, tot, sum[400001];char s[12];void insert(char *s) &#123; len = strlen(s); root = 0; for(int i = 0; i &lt; len; i++) &#123; int id = s[i] - 'a'; if(!trie[root][id]) trie[root][id] = ++tot; sum[trie[root][id]]++; //前缀保存 root = trie[root][id]; &#125;&#125;int search(char *s) &#123; root = 0; len = strlen(s); for(int i = 0; i &lt; len; i++) &#123; int id = s[i] - 'a'; if(!trie[root][id]) return 0; root = trie[root][id]; &#125; //root经过此循环后变成前缀最后一个字母所在位置 return sum[root];&#125;int n, m;int main() &#123; char s[12]; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; s; insert(s); &#125; scanf("%d", &amp;m); for(int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; s; printf("%d\n", search(s)); &#125;&#125; 参考网址: 网址]]></content>
      <tags>
        <tag>All things come to those who wait. 苍天不负有心人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础博弈]]></title>
    <url>%2F2019%2F09%2F08%2F%E5%9F%BA%E7%A1%80%E5%8D%9A%E5%BC%88%2F</url>
    <content type="text"><![CDATA[基础博弈1. 博弈论的简介 博弈论是二人或多人在平等的对局中各自利用对方的策略变换自己的对抗策略，达到取胜目标的理论。博弈论是研究互动决策的理论。博弈可以分析自己与对手的利弊关系，从而确立自己在博弈中的优势，因此有不少博弈理论，可以帮助对弈者分析局势，从而采取相应策略，最终达到取胜的目的。博弈的类型分为：合作博弈、非合作博弈、完全信息博弈、非完全信息博弈、静态博弈、动态博弈，等等。 2. 基础概念 必胜态：通过某一步可以转移到必败态的局面。 也就是说，对于一个处于必胜态的玩家，他总能找到一种合法操作，将当前局面变成一个必败态然后交给对方，如果中途不出现意外的话，最终自己就会得到胜利。但是处于必胜态并不意味着任意的操作都能将当前局面变成必败态。 必败态：通过某一步只能转移到必胜态的局面。 也就是说，处于必败态的玩家无论做什么操作，都只会将当前的局面变成必胜态，然后交给对方，只要对方足够聪明，那么该玩家将输掉比赛。 对于足够聪明的两个博弈者来说，游戏的胜负在比赛前就已经知道(当然，我这里只是说在题目里，在现实中如果是稍微复杂一点的博弈游戏，单凭人脑是很难达到那种水平)，也就是说胜利的一方总能找到胜利的路径，而输掉的那一方无论怎样走，胜利的一方都能找到对应的方法。也就是说先后手以及起始局面可以决定整场博弈的胜负。 3. 巴什博弈（Bash Game） 只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。 求 r=n%(1+m), 判断 r 是否等于 0，如果 r 不等于 0，先手必胜，否则后手必胜。为什么？ 我们可以分析一下，对于 n=(1+m) * r+s，如果 s不等于 0 的话，先手取走s，那么总的物品数剩下 (1+m) * r，然后后手取走 k 的话，先手只要取走 1+m-k 的物品，就可以保持 n=(1+m) 的倍数的局面交给对方，这意味着什么？意味着 n=0 的局面最终会被后手得到，那样后手就输了。而如果s等于0的话，那么对于先手取k的物品，后手只要取 1+m-k 个物品就可以将n=0的局面转给先手，先手就输了。 所以这里的必败态是(1+m)的倍数。有没有发现，对于一场博弈来说，所有的必败态都会有相似的地方，就像这里，必败态一定是(1+m)的倍数。 然后再说深一点的巴什博弈：只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取p个，最多取q个，如果剩下的物品数小于p的话需要一次取完。最后取光者得胜。 这个又怎样求？按照上面的思路，我们可以得到公式n=(p+q)*r+s。 那么这里的s有两种情况①s&gt;=p，②s&lt;p,。 对于①很容易分析，只要先手取走s的话，对于后手去k，先手只要取p+q-k即可保证先手必胜。 对于②，分析起来没有①那么简单，所以这可能就一定需要用后面讲到的用SG值来判断了。 然后在讲一下一个问题。如果条件和基本的巴什博弈基本一样，但是说的是最后谁是无法再取物品的是赢家的话，那该怎么处理呢？ 既然是这样，先手只要判断一下能不能将最后一步留给自己就可以了。而最后一步最少也要保留一个物品，所以我们可以将这个问题转化为基本的巴什博弈，只是终点变成一个物品，而不是零个物品。所以判断的条件是(n-1)%(1+m)!=0 ? 先手赢 : 后手赢。 代码实现 : 1234int Bash_Game(int n,int m) &#123; //是否先手有必赢策略 if (n % (1 + m) != 0) return 1; //先手赢 return 0; //后手赢&#125; 例题:1. HDU1846 (模板题) http://acm.hdu.edu.cn/showproblem.php?pid=1846 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() &#123; int t; cin &gt;&gt; t; while(t--) &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; int s = n % (1 + m); if(s) cout &lt;&lt; "first" &lt;&lt; endl; else cout &lt;&lt; "second" &lt;&lt; endl; &#125; return 0;&#125; 2. HDU4764 (巴什博弈变形) http://acm.hdu.edu.cn/showproblem.php?pid=4764 12345678910111213#include &lt;iostream&gt;using namespace std;int main() &#123; int n, m; while(cin &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m) &#123; int s = (n - 1) % (1 + m); //谁先写到 大于等于n 谁就输 if(s) cout &lt;&lt; "Tang" &lt;&lt; endl; else cout &lt;&lt; "Jiang" &lt;&lt; endl; &#125; return 0;&#125; 4. 尼姆博弈(Nimm Game) 和 扩展 有若干堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 12345678910111213141516171819求 r=n%(1+m), 判断 r 是否等于 0，如果 r 不等于 0，先手必胜，否则后手必胜。为什么？ 我们可以分析一下，对于 n=(1+m) * r+s，如果 s不等于 0 的话，先手取走s，那么总的物品数剩下 (1+m) * r，然后后手取走 k 的话，先手只要取走 1+m-k 的物品，就可以保持 n=(1+m) 的倍数的局面交给对方，这意味着什么？意味着 n=0 的局面最终会被后手得到，那样后手就输了。而如果s等于0的话，那么对于先手取k的物品，后手只要取 1+m-k 个物品就可以将n=0的局面转给先手，先手就输了。 所以这里的必败态是(1+m)的倍数。有没有发现，对于一场博弈来说，所有的必败态都会有相似的地方，就像这里，必败态一定是(1+m)的倍数。 然后再说深一点的巴什博弈：只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取p个，最多取q个，如果剩下的物品数小于p的话需要一次取完。最后取光者得胜。 这个又怎样求？按照上面的思路，我们可以得到公式n=(p+q)*r+s。 那么这里的s有两种情况①s&gt;=p，②s&lt;p,。 对于①很容易分析，只要先手取走s的话，对于后手去k，先手只要取p+q-k即可保证先手必胜。 对于②，分析起来没有①那么简单，所以这可能就一定需要用后面讲到的用SG值来判断了。 然后在讲一下一个问题。如果条件和基本的巴什博弈基本一样，但是说的是最后谁是无法再取物品的是赢家的话，那该怎么处理呢？ 既然是这样，先手只要判断一下能不能将最后一步留给自己就可以了。而最后一步最少也要保留一个物品，所以我们可以将这个问题转化为基本的巴什博弈，只是终点变成一个物品，而不是零个物品。所以判断的条件是(n-1)%(1+m)!=0 ? 先手赢 : 后手赢。 代码实现: 12345678int Nimm_Game(int n) &#123; //假设n个数存在数组f[]中,有必胜策略返回1 int flag = 0; for(int i = 1; i &lt;= n; i++) &#123; flag ^= f[i]; &#125; if(flag) return 1; //先手赢 return 0; //后手赢&#125; 例题:1. 洛谷 P2197 (尼姆博弈 模板) https://www.luogu.org/problem/P2197 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main() &#123; int t; cin &gt;&gt; t; while(t--) &#123; int n, x, ans = 0;; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; x; ans ^= x; &#125; if(ans) cout &lt;&lt; "Yes" &lt;&lt; endl; else cout &lt;&lt; "No" &lt;&lt; endl; &#125; return 0;&#125; 扩展: 求 第一次/每次 取出的数量 123456789101112131415161718192021// 第一次从b堆中取出a个这个游戏的SG值就是各堆数量的异或和，当 SG 为 0 时先手必败，否则先手就要把SG变为0先检验 SG 值，如果是 0 输出 lose，否则我们按照以下原则行动--//----重点来了------有 n 个数的异或值不为 0 现在要减少一个数使异或值为 0假设 n 个数：a1 ,a2,a3...ana1^a2^a3^..^an=k那么我们可以对一个数进行操作,假设这个数是a1，设 a1^k = a'， a'^a2^a3^...^an = a1^a2^a3^...^an^k = k^k = 0;所以我们只需要从头到尾检验每个数异或k的值是否比它小(因为是要减少)，遇到小的直接输出 ai-ai^k 即可//在这里要明白: 假设把每堆石子的数量异或以后得到数为 k (k!=0) 这里 k 并不是第一次要取出 k 个石子 在这里设用 k 去与每堆f[i]异或得到的一个数为 m 若 m &lt; f[i], 则说明第一次是在 第i堆中取了f[i]-k^f[i]个石子 例题:1. 洛谷 P1427 (第一次取出) https://www.luogu.org/problem/P1247 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt; using namespace std;int n;int k[500005];int main() &#123; int ans = 0; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; k[i]; ans ^= k[i]; &#125; if(!ans) &#123; cout &lt;&lt; "lose" &lt;&lt; endl; return 0; &#125; for(int i = 1; i &lt;= n; i++) &#123; if((ans ^ k[i]) &gt;= k[i]) continue; cout &lt;&lt; k[i] - (ans ^ k[i]) &lt;&lt; ' '&lt;&lt; i &lt;&lt; endl; k[i] ^= ans; break; &#125; for(int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; k[i] &lt;&lt; ' '; &#125; cout &lt;&lt; endl; return 0;&#125; 2. HDU 2176 (每次 取出/剩余 ) http://acm.hdu.edu.cn/showproblem.php?pid=2176 12345678910111213141516171819202122232425262728#include &lt;iostream&gt; using namespace std;int n;int k[500005];int main() &#123; while(cin &gt;&gt; n &amp;&amp; n) &#123; int ans = 0; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; k[i]; ans ^= k[i]; &#125; if(!ans) &#123; cout &lt;&lt; "No" &lt;&lt; endl; continue; &#125; cout &lt;&lt; "Yes" &lt;&lt; endl; for(int i = 1; i &lt;= n; i++) &#123; if((ans ^ k[i]) &gt;= k[i]) continue; int t = ans ^ k[i]; //t是按照最优的方法取完石子后，剩下的石子 cout &lt;&lt; k[i] &lt;&lt; ' '&lt;&lt; t &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Better late than never. 只要开始，虽晚不迟.</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下使用 Github + Hexo 搭建私人博客]]></title>
    <url>%2F2019%2F09%2F08%2FLinux%E4%B8%8B%E4%BD%BF%E7%94%A8-Github-Hexo-%E6%90%AD%E5%BB%BA%E7%A7%81%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[在此声明: 注意输入命令时当前的路径, 没有标注的话就是任意路径 一. 搭建Hexo1. Node.js安装首先去官网下载格式为 tar.xz 的安装包 官网链接, 然后解压 然后执行命令 12345678910111213//此操作通过创建软链接执行，语法格式为 ln -s 源文件 目标文件，参数-s为软链接（符号链接）[root@changjianing]# ln -s /home/changjianing/Downloads/node-v10.16.3-linux-x64/bin/node /usr/local/bin/node[root@changjianing]# ln -s /home/changjianing/Downloads/node-v10.16.3-linux-x64/bin/npm /usr/local/bin/npm//(这里注意版本区别)//如果显示: /usr/local/bin/node已存在 或 /usr/local/bin/npm已存在就到这个路径(/usr/local/bin/node),把node删了再次执行此命令或就到这个路径(/usr/local/bin/npm),把npm删了再次执行此命令 2. 安装 gitsudo apt-get install git 给一个学习 git 的网站 Git教程 3. 安装 HexoHexo 操作命令官网 官网链接 (了解) npm install hexo-cli -g //安装Hexo 若此命令不能执行,则进行以下操作 (安装npm) 1234567//npm的源在国外，没翻墙的话速度会很慢，可以改成国内的淘宝源 (执行以下3行命令)npm config set registry https://registry.npm.taobao.orgnpm config listsudo apt-get install npm//然后再安装 Hexonpm install hexo-cli -g (或 npm install -g hexo-cli) 此处安装完成后，需要将Hexo添加到全局变量中。否则会提示找不到命令 ln -s /home/changjianing/Downloads/node-v10.16.3-linux-x64/lib/node_modules/hexo-cli/bin/hexo /usr/local/bin/hexo 4. 部署 Hexo 博客环境1) 部署 Hexo 可以放在和 Node.js 同层级的目录 1234567891011121314151617[root@changjianing Downloads]# pwd/home/changjianing/Downloads[root@changjianing Downloads]# mkdir hexo[root@changjianing Downloads]# cd hexo/[root@changjianing hexo]# hexo init # 新建一个网站，默认在目前的文件夹建立网站。[root@changjianing hexo]# ll //ll不行 可以lstotal 168-rw-r--r-- 1 root root 1765 Jun 4 16:14 _config.ymldrwxr-xr-x 285 root root 12288 Jun 4 16:15 node_modules-rw-r--r-- 1 root root 443 Jun 4 16:14 package.json-rw-r--r-- 1 root root 138442 Jun 4 16:15 package-lock.jsondrwxr-xr-x 2 root root 4096 Jun 4 16:14 scaffoldsdrwxr-xr-x 3 root root 4096 Jun 4 16:14 sourcedrwxr-xr-x 3 root root 4096 Jun 4 16:14 themes[root@changjianing hexo]# ll themes/ # 查看自带的主题total 4drwxr-xr-x 6 root root 4096 Jun 4 16:14 landscape 2) 启动环境测试 123456789101112131415[root@changjianing hexo]# hexo g # 生成静态文件[root@changjianing hexo]# lltotal 200-rw-r--r-- 1 root root 1765 Jun 4 16:14 _config.yml-rw-r--r-- 1 root root 25063 Jun 4 16:26 db.jsondrwxr-xr-x 285 root root 12288 Jun 4 16:15 node_modules-rw-r--r-- 1 root root 447 Jun 4 16:26 package.json-rw-r--r-- 1 root root 138442 Jun 4 16:15 package-lock.jsondrwxr-xr-x 7 root root 4096 Jun 4 16:26 public # 生成的静态文件drwxr-xr-x 2 root root 4096 Jun 4 16:14 scaffoldsdrwxr-xr-x 3 root root 4096 Jun 4 16:14 sourcedrwxr-xr-x 3 root root 4096 Jun 4 16:14 themes[root@changjianing hexo]# hexo s # 启动服务，默认是 http://localhost:4000INFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 3) 浏览器访问 (选择执行) 123http://www.zhangblog.com:4000///下面给出别人的访问情况, 自己的没有截图 访问情况 二. 将 Hexo 和 Github Pages 结合1. 注册 Github 账号Github 官网 2. 使用Github Pages创建指定的Github仓库, 点击创建按钮 仓库名称和配置选择 开启 Github Pages, 进入 Settings 默认已开启 Github Pages 选择主题, 并查看 具体情况 浏览器访问 1https://zhanglianghhh.github.io/ 访问情况 3. 在Github 上添加 SSH秘钥 并配置1234567891011121314151617181920212223242526272829303132[root@changjianing ~]# ssh-keygen -t rsa # 如果遇见等待输入的地方，按下 Enter 回车键即可，无需任何其他输入Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:SHA256:73zrQW4LTBgAVqQKvOoTxFrgaGF/sobf643Q+3w7or0 root@zhangblogThe key&apos;s randomart image is:+---[RSA 2048]----+| o++ ||oo . . . ||*oo . . ||.*o+ . o ||+oo + S . . ||oo o. + o ||. +... + + ||.. ...*. = o.o || .. .*+E+.=o+. |+----[SHA256]-----+[root@changjianing ~]# cd .ssh/[root@changjianing .ssh]# lltotal 12-rw------- 1 root root 0 Jun 3 17:02 authorized_keys-rw------- 1 root root 1675 Jun 5 14:17 id_rsa-rw-r--r-- 1 root root 396 Jun 5 14:17 id_rsa.pub-rw-r--r-- 1 root root 395 Dec 14 17:15 known_hosts[root@changjianing .ssh]# cat id_rsa.pub # 具体的公钥信息ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQD4iDDDDDDDDDDgMMutdH7KdI5P7BrtHbfRG+MYyr1/Gtz45hJgbVHBCTFZaTn2+MekFQcZVkyc2kEU7L7mm4ZGWkStgbXkas+uTFwo3kLlX8ozcUC3jM8rhzbWPv8piq58ezBnrMZ0zNsCgHGXpokUmLqYt1mpLXz5rsOzwGgHHkp+Wlr+6tTQxr/+9T4CiE/RkFKi/mehn01rjOcVluYSkwkVii03EzMlMcoyV3ctnWzwyZIWAQAsvDSN2CQAdRtaUHOJOAoRv8/s4jDiWU1ia0JYmm2D/IWcLl2hxNtGeVHTFk9l1djtUQu47zuoOM4y6ySlUx28HNIAMw14gjIv5 root@zhangblog Github 添加 SSH秘钥 Github 连接测试 1234567[root@changjianing ~]# ssh -T git@github.comThe authenticity of host 'github.com (13.250.177.223)' can't be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.RSA key fingerprint is MD5:16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? yes //输入yes就行Warning: Permanently added 'github.com,13.250.177.223' (RSA) to the list of known hosts.Hi zhanglianghhh! You've successfully authenticated, but GitHub does not provide shell access. 可见连接 Github 成功 4. 设置账号信息123[root@changjianing hexo]# git config --global user.name &quot;zhanglianghhh&quot; //这里填写你创建网站的名字[root@changjianing hexo]# git config --global user.email &quot;zhanglianghhh@163.com&quot; //这里填写你Github上的邮箱 5. Hexo 部署到 Github Pages_config.yml 配置修改 1234567891011[root@changjianing hexo]# pwd/home/changjianing/Downloads/hexo //注意这里的路径(搭建Hexo时创建的hexo文件夹)[root@changjianing hexo]# vim _config.yml………………# Deployment## Docs: https://hexo.io/docs/deployment.html # 修改或添加如下信息deploy: type: git repo: git@github.com:zhanglianghhh/zhanglianghhh.github.io.git //填写自己的信息 branch: master 在部署到 GitHub 之前，还需要安装如下扩展： 1234[root@changjianing hexo]# pwd # 站点目录/home/changjianing/Downloads/hexo[root@changjianing hexo]# npm install hexo-deployer-git --save 部署到 Github 1234[root@changjianing hexo]# pwd/home/changjianing/Downloads/hexo[root@changjianing hexo]# hexo d -g # 部署前，先生成静态文件 -g 可选 浏览器访问 12https://zhanglianghhh.github.io/ # GitHub Pages 的访问http://www.zhangblog.com/ # 个人网站的访问 三. 更换 Hexo主题1. 进入官网挑选喜欢的主题Hexo主题官网 可以看到有很多主题给我们选，我们只要选择喜欢的主题点击进去，然后进入到它的github地址，我们只要把这个地址复制下来(例如我是选择：hexo-theme-next这个主题) 2. 克隆主题再打开 hexo文件夹下的 themes 目录 1234[root@changjianing themes]# pwd/home/changjianing/Downloads/hexo/themes[root@changjianing themes]# git clone https://github.com/iissnan/hexo-theme-next(此处地址替换成你需要使用的主题的地址) 下载中，等待下载完成 3. 修改hexo配置文件下载完成后, 打开 hexo 中的 _config.yml 文件 123456[root@changjianing hexo]# pwd/home/changjianing/Downloads/hexo[root@changjianing hexo]# vim _config.yml//修改参数为: theme: hexo-theme-next 4. 部署主题, 本地查看效果返回 hexo 目录 12345[root@changjianing hexo]# pwd/home/changjianing/Downloads/hexo[root@changjianing hexo]# hexo g[root@changjianing hexo]# hexo s 打开浏览器，输入 http://localhost:4000/ 即可看见我们的主题已经更换了 5. 如果效果满意, 就将它部署到 Github 上12345[root@changjianing hexo]# pwd/home/changjianing/Downloads/hexo[root@changjianing hexo]# hexo clean //必须要，不然有时因为缓存问题，服务器更新不了主题[root@changjianing hexo]# hexo g -d 6. 打开自己的主页, 即可查看效果更多具体修改请查看对应主题的说明文档 四. 新建/删除 博客文章1. 用 hexo 发表新文章12345678910111213[root@changjianing hexo]# pwd/home/changjianing/Downloads/hexo[root@changjianing hexo]# hexo n "文章标题" //-----其中 我的家 为文章标题，执行命令 hexo n "我的家" 后会在项目 \hexo\source_posts 中生成 我的家.md文件，用编辑器打开编写即可当然，也可以直接在 \hexo\source\_posts 中新建一个 md 文件，我就是这么做的。 写完后，推送到服务器上，执行以下命令即可在我们的站点看到新的文章。 //如果执行命令: hexo n "文章标题" 出现未找到命令//则需重装Hexo,执行次命令即可: npm install hexo-cli -g 然后执行以下操作 12345[root@changjianing hexo]# pwd/home/changjianing/Downloads/hexo[root@changjianing hexo]# hexo g //生成[root@changjianing hexo]# hexo d //部署 打开自己的主页,即可查看效果 2. 删除文章删除文章的过程一样也很简单，先删除本地文件，然后通过生成和部署命令进而将远程仓库中的文件也一并删除。具体来说，以最开始默认形成的 helloworld.md 这篇文章为例。 首先进入到 /home/changjianing/hexo/source/_post 文件夹中，找到 helloworld.md 文件，在本地直接执行删除 然后执行以下操作: 12[root@changjianing hexo]# hexo g //生成[root@changjianing hexo]# hexo d //部署 然后去主页即可查看效果 五. 参考网址1. 搭建 Hexo 2. 将 Hexo 和 Github Pages 结合 3. 更换 Hexo 主题 和 新建文章 4. 删除文章]]></content>
      <tags>
        <tag>Do what you say,say what you do. 做你说过的，说你能做的</tag>
      </tags>
  </entry>
</search>
