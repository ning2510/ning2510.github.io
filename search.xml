<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[字典树 (Trie 树)]]></title>
    <url>%2F2019%2F09%2F11%2F%E5%AD%97%E5%85%B8%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1. 引入字典是干啥的？查找字的。 字典树自然也是起查找作用的。查找的是啥？单词。 看以下几个题： 1) 给出n个单词和m个询问，每次询问一个单词，回答这个单词是否在单词表中出现过。 答：简单！map，短小精悍。 好。下一个 2) 给出n个单词和m个询问，每次询问一个前缀，回答询问是多少个单词的前缀。 答：map，把每个单词拆开。 judge：n&lt;=200000，TLE！ 这就需要一种高级数据结构——Trie树（字典树） 2. 原理在本篇文章中，假设 所有单词都只由小写字母 构成 对cat，cash，app，apple，aply，ok 建一颗字典树，建成之后如下图所示 由此可以看出： 1、字典树用边表示字母 2、有相同前缀的单词公用前缀节点，那我们可以的得出每个节点最多有26个子节点（在单词只包含小写字母的情况下） 3、整棵树的根节点是空的。为什么呢？便于插入和查找，这将会在后面解释。 4、每个单词结束的时候用一个特殊字符表示，图中用的‘′，那么从根节点到任意一个‘′，那么从根节点到任意一个‘’所经过的边的所有字母表示一个单词。 3. 基本操作1. insert 插入一个单词思路: 从图中可以直观看出，从左到右扫这个单词，如果字母在相应根节点下没有出现过，就插入这个字母；否则沿着字典树往下走，看单词的下一个字母。 这就产生一个问题：往哪儿插？计算机不会自己选择位置插，我们需要给它指定一个位置，那就需要给每个字母编号。 我们设数组trie[i][j]=k，表示编号为i的节点的第j个孩子是编号为k的节点。 什么意思呢？ 这里有2种编号，一种是i，k表示节点的位置编号，这是相对整棵树而言的；另一种是j，表示节点i的第j的孩子，这是相对节点i而言的。 不理解？看图 还是单词cat，cash，app，apple，aply，ok 我们就按输入顺序对其编第一种号，红色表示编号结果。因为先输入的cat，所以c，a，t分别是1,2,3，然后输入的是cash，因为c，a是公共前缀，所以从s开始编，s是4，以此类推。 注意这里相同字母的编号可能不同 第二种编号，相对节点的编号，紫色表示编号结果。 因为每个节点最多有26个子节点，我们可以按他们的字典序从0——25编号，也就是他们的ASCLL码-a的ASCLL码。 注意这里相同字母的编号相同 实际上每个节点的子节点都应该从0编到——25，但这样会发现许多事根本用不到的。比如上图的根节点应该分出26个叉。节约空间，用到哪个分哪个。 这样编号有什么用呢？ 回到数组trie[i][j]=k。 数组trie[i][j]=k，表示编号为i的节点的第j个孩子是编号为k的节点。 那么第二种编号即为j，第一种编号即为i，k 代码实现: 12345678910void insert() &#123; //插入单词s len = strlen(s); //单词s的长度 root = 0; //根节点编号为0 for(int i = 0; i &lt; len; i++) &#123; int id = s[i] - 'a'; //第二种编号 if(!trie[root][id]) //如果之前没有从root到id的前缀 trie[root][id] = ++tot; //插入，tot即为第一种编号 root = trie[root][id]; //顺着字典树往下走 &#125;&#125; 2. search 查找思路: 从左往右以此扫描每个字母，顺着字典树往下找，能找到这个字母，往下走，否则结束查找，即没有这个前缀；前缀扫完了，表示有这个前缀。 代码实现: 1234567891011bool find() &#123; len = strlen(s); root = 0; //从根结点开始找 for(int i = 0; s[i]; i++) &#123; int x = s[i] - 'a';// if(trie[root][x] == 0) return false; //以root为头结点的x字母不存在，返回0 root = trie[root][x]; //为查询下个字母做准备，往下走 &#125; return true;//找到了&#125; 3、如果是查询某个单词的话，我们用bool变量 v[i]表示节点i是否是单词结束的标志。 ​ 那么最后return的是v[root],所以在插入操作中插入完每个单词是，要对单词最后一个字母的v[i]置为true，其他的都是false 4、如果是查询前缀出现的次数的话，那就在开一个sum[]，表示位置i被访问过的次数 那么最后return的是sum[root]，插入操作中每访问一个节点，都要让他的sum++ 这里前缀的次数是标记在前缀的最后一个字母所在位置的后一个位置上。 比如:前缀abc出现的次数标记在c所在位置的后一个位置上 3. 完整代码实现1. 查询是否出现 (前缀 或 全部) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* trie tree的储存方式：将字母储存在边上，边的节点连接与它相连的字母 trie[rt][x]=tot:rt是上个节点编号，x是字母，tot是下个节点编号 */ #include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define maxn 2000010using namespace std;int tot = 1, n;int trie[maxn][26];//bool isw[maxn];查询整个单词用void insert(char *s, int rt) &#123; for(int i = 0; s[i]; i++) &#123; int x = s[i] - 'a'; if(trie[rt][x] == 0) &#123; //现在插入的字母在之前同一节点处未出现过 trie[rt][x] = ++tot;//字母插入一个新的位置，否则不做处理 &#125; rt = trie[rt][x];//为下个字母的插入做准备 &#125; /*isw[rt] = true;标志该单词末位字母的尾结点，在查询整个单词时用到*/&#125;bool find(char *s, int rt) &#123; for(int i = 0; s[i]; i++) &#123; int x = s[i] - 'a'; if(trie[rt][x] == 0) return false; //以rt为头结点的x字母不存在，返回0 rt = trie[rt][x]; //为查询下个字母做准备 &#125; return true; //查询整个单词时，应该return isw[rt] &#125;char s[22];int main() &#123; tot = 0; int rt = 0; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; s; insert(s, rt); &#125; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; s; if(find(s, rt)) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; 2. 查询前缀出现次数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int trie[400001][26], len, root, tot, sum[400001];char s[12];void insert(char *s) &#123; len = strlen(s); root = 0; for(int i = 0; i &lt; len; i++) &#123; int id = s[i] - 'a'; if(!trie[root][id]) trie[root][id] = ++tot; sum[trie[root][id]]++; //前缀保存 root = trie[root][id]; &#125;&#125;int search(char *s) &#123; root = 0; len = strlen(s); for(int i = 0; i &lt; len; i++) &#123; int id = s[i] - 'a'; if(!trie[root][id]) return 0; root = trie[root][id]; &#125; //root经过此循环后变成前缀最后一个字母所在位置 return sum[root];&#125;int n, m;int main() &#123; char s[12]; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; s; insert(s); &#125; scanf("%d", &amp;m); for(int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; s; printf("%d\n", search(s)); &#125;&#125; 参考网址: 网址]]></content>
      <tags>
        <tag>All things come to those who wait. 苍天不负有心人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础博弈]]></title>
    <url>%2F2019%2F09%2F08%2F%E5%9F%BA%E7%A1%80%E5%8D%9A%E5%BC%88%2F</url>
    <content type="text"><![CDATA[基础博弈1. 博弈论的简介 博弈论是二人或多人在平等的对局中各自利用对方的策略变换自己的对抗策略，达到取胜目标的理论。博弈论是研究互动决策的理论。博弈可以分析自己与对手的利弊关系，从而确立自己在博弈中的优势，因此有不少博弈理论，可以帮助对弈者分析局势，从而采取相应策略，最终达到取胜的目的。博弈的类型分为：合作博弈、非合作博弈、完全信息博弈、非完全信息博弈、静态博弈、动态博弈，等等。 2. 基础概念 必胜态：通过某一步可以转移到必败态的局面。 也就是说，对于一个处于必胜态的玩家，他总能找到一种合法操作，将当前局面变成一个必败态然后交给对方，如果中途不出现意外的话，最终自己就会得到胜利。但是处于必胜态并不意味着任意的操作都能将当前局面变成必败态。 必败态：通过某一步只能转移到必胜态的局面。 也就是说，处于必败态的玩家无论做什么操作，都只会将当前的局面变成必胜态，然后交给对方，只要对方足够聪明，那么该玩家将输掉比赛。 对于足够聪明的两个博弈者来说，游戏的胜负在比赛前就已经知道(当然，我这里只是说在题目里，在现实中如果是稍微复杂一点的博弈游戏，单凭人脑是很难达到那种水平)，也就是说胜利的一方总能找到胜利的路径，而输掉的那一方无论怎样走，胜利的一方都能找到对应的方法。也就是说先后手以及起始局面可以决定整场博弈的胜负。 3. 巴什博弈（Bash Game） 只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。 求 r=n%(1+m), 判断 r 是否等于 0，如果 r 不等于 0，先手必胜，否则后手必胜。为什么？ 我们可以分析一下，对于 n=(1+m) * r+s，如果 s不等于 0 的话，先手取走s，那么总的物品数剩下 (1+m) * r，然后后手取走 k 的话，先手只要取走 1+m-k 的物品，就可以保持 n=(1+m) 的倍数的局面交给对方，这意味着什么？意味着 n=0 的局面最终会被后手得到，那样后手就输了。而如果s等于0的话，那么对于先手取k的物品，后手只要取 1+m-k 个物品就可以将n=0的局面转给先手，先手就输了。 所以这里的必败态是(1+m)的倍数。有没有发现，对于一场博弈来说，所有的必败态都会有相似的地方，就像这里，必败态一定是(1+m)的倍数。 然后再说深一点的巴什博弈：只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取p个，最多取q个，如果剩下的物品数小于p的话需要一次取完。最后取光者得胜。 这个又怎样求？按照上面的思路，我们可以得到公式n=(p+q)*r+s。 那么这里的s有两种情况①s&gt;=p，②s&lt;p,。 对于①很容易分析，只要先手取走s的话，对于后手去k，先手只要取p+q-k即可保证先手必胜。 对于②，分析起来没有①那么简单，所以这可能就一定需要用后面讲到的用SG值来判断了。 然后在讲一下一个问题。如果条件和基本的巴什博弈基本一样，但是说的是最后谁是无法再取物品的是赢家的话，那该怎么处理呢？ 既然是这样，先手只要判断一下能不能将最后一步留给自己就可以了。而最后一步最少也要保留一个物品，所以我们可以将这个问题转化为基本的巴什博弈，只是终点变成一个物品，而不是零个物品。所以判断的条件是(n-1)%(1+m)!=0 ? 先手赢 : 后手赢。 代码实现 : 1234int Bash_Game(int n,int m) &#123; //是否先手有必赢策略 if (n % (1 + m) != 0) return 1; //先手赢 return 0; //后手赢&#125; 例题:1. HDU1846 (模板题) http://acm.hdu.edu.cn/showproblem.php?pid=1846 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() &#123; int t; cin &gt;&gt; t; while(t--) &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; int s = n % (1 + m); if(s) cout &lt;&lt; "first" &lt;&lt; endl; else cout &lt;&lt; "second" &lt;&lt; endl; &#125; return 0;&#125; 2. HDU4764 (巴什博弈变形) http://acm.hdu.edu.cn/showproblem.php?pid=4764 12345678910111213#include &lt;iostream&gt;using namespace std;int main() &#123; int n, m; while(cin &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m) &#123; int s = (n - 1) % (1 + m); //谁先写到 大于等于n 谁就输 if(s) cout &lt;&lt; "Tang" &lt;&lt; endl; else cout &lt;&lt; "Jiang" &lt;&lt; endl; &#125; return 0;&#125; 4. 尼姆博弈(Nimm Game) 和 扩展 有若干堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 12345678910111213141516171819求 r=n%(1+m), 判断 r 是否等于 0，如果 r 不等于 0，先手必胜，否则后手必胜。为什么？ 我们可以分析一下，对于 n=(1+m) * r+s，如果 s不等于 0 的话，先手取走s，那么总的物品数剩下 (1+m) * r，然后后手取走 k 的话，先手只要取走 1+m-k 的物品，就可以保持 n=(1+m) 的倍数的局面交给对方，这意味着什么？意味着 n=0 的局面最终会被后手得到，那样后手就输了。而如果s等于0的话，那么对于先手取k的物品，后手只要取 1+m-k 个物品就可以将n=0的局面转给先手，先手就输了。 所以这里的必败态是(1+m)的倍数。有没有发现，对于一场博弈来说，所有的必败态都会有相似的地方，就像这里，必败态一定是(1+m)的倍数。 然后再说深一点的巴什博弈：只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取p个，最多取q个，如果剩下的物品数小于p的话需要一次取完。最后取光者得胜。 这个又怎样求？按照上面的思路，我们可以得到公式n=(p+q)*r+s。 那么这里的s有两种情况①s&gt;=p，②s&lt;p,。 对于①很容易分析，只要先手取走s的话，对于后手去k，先手只要取p+q-k即可保证先手必胜。 对于②，分析起来没有①那么简单，所以这可能就一定需要用后面讲到的用SG值来判断了。 然后在讲一下一个问题。如果条件和基本的巴什博弈基本一样，但是说的是最后谁是无法再取物品的是赢家的话，那该怎么处理呢？ 既然是这样，先手只要判断一下能不能将最后一步留给自己就可以了。而最后一步最少也要保留一个物品，所以我们可以将这个问题转化为基本的巴什博弈，只是终点变成一个物品，而不是零个物品。所以判断的条件是(n-1)%(1+m)!=0 ? 先手赢 : 后手赢。 代码实现: 12345678int Nimm_Game(int n) &#123; //假设n个数存在数组f[]中,有必胜策略返回1 int flag = 0; for(int i = 1; i &lt;= n; i++) &#123; flag ^= f[i]; &#125; if(flag) return 1; //先手赢 return 0; //后手赢&#125; 例题:1. 洛谷 P2197 (尼姆博弈 模板) https://www.luogu.org/problem/P2197 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main() &#123; int t; cin &gt;&gt; t; while(t--) &#123; int n, x, ans = 0;; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; x; ans ^= x; &#125; if(ans) cout &lt;&lt; "Yes" &lt;&lt; endl; else cout &lt;&lt; "No" &lt;&lt; endl; &#125; return 0;&#125; 扩展: 求 第一次/每次 取出的数量 123456789101112131415161718192021// 第一次从b堆中取出a个这个游戏的SG值就是各堆数量的异或和，当 SG 为 0 时先手必败，否则先手就要把SG变为0先检验 SG 值，如果是 0 输出 lose，否则我们按照以下原则行动--//----重点来了------有 n 个数的异或值不为 0 现在要减少一个数使异或值为 0假设 n 个数：a1 ,a2,a3...ana1^a2^a3^..^an=k那么我们可以对一个数进行操作,假设这个数是a1，设 a1^k = a'， a'^a2^a3^...^an = a1^a2^a3^...^an^k = k^k = 0;所以我们只需要从头到尾检验每个数异或k的值是否比它小(因为是要减少)，遇到小的直接输出 ai-ai^k 即可//在这里要明白: 假设把每堆石子的数量异或以后得到数为 k (k!=0) 这里 k 并不是第一次要取出 k 个石子 在这里设用 k 去与每堆f[i]异或得到的一个数为 m 若 m &lt; f[i], 则说明第一次是在 第i堆中取了f[i]-k^f[i]个石子 例题:1. 洛谷 P1427 (第一次取出) https://www.luogu.org/problem/P1247 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt; using namespace std;int n;int k[500005];int main() &#123; int ans = 0; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; k[i]; ans ^= k[i]; &#125; if(!ans) &#123; cout &lt;&lt; "lose" &lt;&lt; endl; return 0; &#125; for(int i = 1; i &lt;= n; i++) &#123; if((ans ^ k[i]) &gt;= k[i]) continue; cout &lt;&lt; k[i] - (ans ^ k[i]) &lt;&lt; ' '&lt;&lt; i &lt;&lt; endl; k[i] ^= ans; break; &#125; for(int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; k[i] &lt;&lt; ' '; &#125; cout &lt;&lt; endl; return 0;&#125; 2. HDU 2176 (每次 取出/剩余 ) http://acm.hdu.edu.cn/showproblem.php?pid=2176 12345678910111213141516171819202122232425262728#include &lt;iostream&gt; using namespace std;int n;int k[500005];int main() &#123; while(cin &gt;&gt; n &amp;&amp; n) &#123; int ans = 0; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; k[i]; ans ^= k[i]; &#125; if(!ans) &#123; cout &lt;&lt; "No" &lt;&lt; endl; continue; &#125; cout &lt;&lt; "Yes" &lt;&lt; endl; for(int i = 1; i &lt;= n; i++) &#123; if((ans ^ k[i]) &gt;= k[i]) continue; int t = ans ^ k[i]; //t是按照最优的方法取完石子后，剩下的石子 cout &lt;&lt; k[i] &lt;&lt; ' '&lt;&lt; t &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Better late than never. 只要开始，虽晚不迟.</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下使用 Github + Hexo 搭建私人博客]]></title>
    <url>%2F2019%2F09%2F08%2FLinux%E4%B8%8B%E4%BD%BF%E7%94%A8-Github-Hexo-%E6%90%AD%E5%BB%BA%E7%A7%81%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[在此声明: 注意输入命令时当前的路径, 没有标注的话就是任意路径 一. 搭建Hexo1. Node.js安装首先去官网下载格式为 tar.xz 的安装包 官网链接, 然后解压 然后执行命令 12345678910111213//此操作通过创建软链接执行，语法格式为 ln -s 源文件 目标文件，参数-s为软链接（符号链接）[root@changjianing]# ln -s /home/changjianing/Downloads/node-v10.16.3-linux-x64/bin/node /usr/local/bin/node[root@changjianing]# ln -s /home/changjianing/Downloads/node-v10.16.3-linux-x64/bin/npm /usr/local/bin/npm//(这里注意版本区别)//如果显示: /usr/local/bin/node已存在 或 /usr/local/bin/npm已存在就到这个路径(/usr/local/bin/node),把node删了再次执行此命令或就到这个路径(/usr/local/bin/npm),把npm删了再次执行此命令 2. 安装 gitsudo apt-get install git 给一个学习 git 的网站 Git教程 3. 安装 HexoHexo 操作命令官网 官网链接 (了解) npm install hexo-cli -g //安装Hexo 若此命令不能执行,则进行以下操作 (安装npm) 1234567//npm的源在国外，没翻墙的话速度会很慢，可以改成国内的淘宝源 (执行以下3行命令)npm config set registry https://registry.npm.taobao.orgnpm config listsudo apt-get install npm//然后再安装 Hexonpm install hexo-cli -g (或 npm install -g hexo-cli) 此处安装完成后，需要将Hexo添加到全局变量中。否则会提示找不到命令 ln -s /home/changjianing/Downloads/node-v10.16.3-linux-x64/lib/node_modules/hexo-cli/bin/hexo /usr/local/bin/hexo 4. 部署 Hexo 博客环境1) 部署 Hexo 可以放在和 Node.js 同层级的目录 1234567891011121314151617[root@changjianing Downloads]# pwd/home/changjianing/Downloads[root@changjianing Downloads]# mkdir hexo[root@changjianing Downloads]# cd hexo/[root@changjianing hexo]# hexo init # 新建一个网站，默认在目前的文件夹建立网站。[root@changjianing hexo]# ll //ll不行 可以lstotal 168-rw-r--r-- 1 root root 1765 Jun 4 16:14 _config.ymldrwxr-xr-x 285 root root 12288 Jun 4 16:15 node_modules-rw-r--r-- 1 root root 443 Jun 4 16:14 package.json-rw-r--r-- 1 root root 138442 Jun 4 16:15 package-lock.jsondrwxr-xr-x 2 root root 4096 Jun 4 16:14 scaffoldsdrwxr-xr-x 3 root root 4096 Jun 4 16:14 sourcedrwxr-xr-x 3 root root 4096 Jun 4 16:14 themes[root@changjianing hexo]# ll themes/ # 查看自带的主题total 4drwxr-xr-x 6 root root 4096 Jun 4 16:14 landscape 2) 启动环境测试 123456789101112131415[root@changjianing hexo]# hexo g # 生成静态文件[root@changjianing hexo]# lltotal 200-rw-r--r-- 1 root root 1765 Jun 4 16:14 _config.yml-rw-r--r-- 1 root root 25063 Jun 4 16:26 db.jsondrwxr-xr-x 285 root root 12288 Jun 4 16:15 node_modules-rw-r--r-- 1 root root 447 Jun 4 16:26 package.json-rw-r--r-- 1 root root 138442 Jun 4 16:15 package-lock.jsondrwxr-xr-x 7 root root 4096 Jun 4 16:26 public # 生成的静态文件drwxr-xr-x 2 root root 4096 Jun 4 16:14 scaffoldsdrwxr-xr-x 3 root root 4096 Jun 4 16:14 sourcedrwxr-xr-x 3 root root 4096 Jun 4 16:14 themes[root@changjianing hexo]# hexo s # 启动服务，默认是 http://localhost:4000INFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 3) 浏览器访问 (选择执行) 123http://www.zhangblog.com:4000///下面给出别人的访问情况, 自己的没有截图 访问情况 二. 将 Hexo 和 Github Pages 结合1. 注册 Github 账号Github 官网 2. 使用Github Pages创建指定的Github仓库, 点击创建按钮 仓库名称和配置选择 开启 Github Pages, 进入 Settings 默认已开启 Github Pages 选择主题, 并查看 具体情况 浏览器访问 1https://zhanglianghhh.github.io/ 访问情况 3. 在Github 上添加 SSH秘钥 并配置1234567891011121314151617181920212223242526272829303132[root@changjianing ~]# ssh-keygen -t rsa # 如果遇见等待输入的地方，按下 Enter 回车键即可，无需任何其他输入Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:SHA256:73zrQW4LTBgAVqQKvOoTxFrgaGF/sobf643Q+3w7or0 root@zhangblogThe key&apos;s randomart image is:+---[RSA 2048]----+| o++ ||oo . . . ||*oo . . ||.*o+ . o ||+oo + S . . ||oo o. + o ||. +... + + ||.. ...*. = o.o || .. .*+E+.=o+. |+----[SHA256]-----+[root@changjianing ~]# cd .ssh/[root@changjianing .ssh]# lltotal 12-rw------- 1 root root 0 Jun 3 17:02 authorized_keys-rw------- 1 root root 1675 Jun 5 14:17 id_rsa-rw-r--r-- 1 root root 396 Jun 5 14:17 id_rsa.pub-rw-r--r-- 1 root root 395 Dec 14 17:15 known_hosts[root@changjianing .ssh]# cat id_rsa.pub # 具体的公钥信息ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQD4iDDDDDDDDDDgMMutdH7KdI5P7BrtHbfRG+MYyr1/Gtz45hJgbVHBCTFZaTn2+MekFQcZVkyc2kEU7L7mm4ZGWkStgbXkas+uTFwo3kLlX8ozcUC3jM8rhzbWPv8piq58ezBnrMZ0zNsCgHGXpokUmLqYt1mpLXz5rsOzwGgHHkp+Wlr+6tTQxr/+9T4CiE/RkFKi/mehn01rjOcVluYSkwkVii03EzMlMcoyV3ctnWzwyZIWAQAsvDSN2CQAdRtaUHOJOAoRv8/s4jDiWU1ia0JYmm2D/IWcLl2hxNtGeVHTFk9l1djtUQu47zuoOM4y6ySlUx28HNIAMw14gjIv5 root@zhangblog Github 添加 SSH秘钥 Github 连接测试 1234567[root@changjianing ~]# ssh -T git@github.comThe authenticity of host 'github.com (13.250.177.223)' can't be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.RSA key fingerprint is MD5:16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? yes //输入yes就行Warning: Permanently added 'github.com,13.250.177.223' (RSA) to the list of known hosts.Hi zhanglianghhh! You've successfully authenticated, but GitHub does not provide shell access. 可见连接 Github 成功 4. 设置账号信息123[root@changjianing hexo]# git config --global user.name &quot;zhanglianghhh&quot; //这里填写你创建网站的名字[root@changjianing hexo]# git config --global user.email &quot;zhanglianghhh@163.com&quot; //这里填写你Github上的邮箱 5. Hexo 部署到 Github Pages_config.yml 配置修改 1234567891011[root@changjianing hexo]# pwd/home/changjianing/Downloads/hexo //注意这里的路径(搭建Hexo时创建的hexo文件夹)[root@changjianing hexo]# vim _config.yml………………# Deployment## Docs: https://hexo.io/docs/deployment.html # 修改或添加如下信息deploy: type: git repo: git@github.com:zhanglianghhh/zhanglianghhh.github.io.git //填写自己的信息 branch: master 在部署到 GitHub 之前，还需要安装如下扩展： 1234[root@changjianing hexo]# pwd # 站点目录/home/changjianing/Downloads/hexo[root@changjianing hexo]# npm install hexo-deployer-git --save 部署到 Github 1234[root@changjianing hexo]# pwd/home/changjianing/Downloads/hexo[root@changjianing hexo]# hexo d -g # 部署前，先生成静态文件 -g 可选 浏览器访问 12https://zhanglianghhh.github.io/ # GitHub Pages 的访问http://www.zhangblog.com/ # 个人网站的访问 三. 更换 Hexo主题1. 进入官网挑选喜欢的主题Hexo主题官网 可以看到有很多主题给我们选，我们只要选择喜欢的主题点击进去，然后进入到它的github地址，我们只要把这个地址复制下来(例如我是选择：hexo-theme-next这个主题) 2. 克隆主题再打开 hexo文件夹下的 themes 目录 1234[root@changjianing themes]# pwd/home/changjianing/Downloads/hexo/themes[root@changjianing themes]# git clone https://github.com/iissnan/hexo-theme-next(此处地址替换成你需要使用的主题的地址) 下载中，等待下载完成 3. 修改hexo配置文件下载完成后, 打开 hexo 中的 _config.yml 文件 123456[root@changjianing hexo]# pwd/home/changjianing/Downloads/hexo[root@changjianing hexo]# vim _config.yml//修改参数为: theme: hexo-theme-next 4. 部署主题, 本地查看效果返回 hexo 目录 12345[root@changjianing hexo]# pwd/home/changjianing/Downloads/hexo[root@changjianing hexo]# hexo g[root@changjianing hexo]# hexo s 打开浏览器，输入 http://localhost:4000/ 即可看见我们的主题已经更换了 5. 如果效果满意, 就将它部署到 Github 上12345[root@changjianing hexo]# pwd/home/changjianing/Downloads/hexo[root@changjianing hexo]# hexo clean //必须要，不然有时因为缓存问题，服务器更新不了主题[root@changjianing hexo]# hexo g -d 6. 打开自己的主页, 即可查看效果更多具体修改请查看对应主题的说明文档 四. 新建/删除 博客文章1. 用 hexo 发表新文章12345678910111213[root@changjianing hexo]# pwd/home/changjianing/Downloads/hexo[root@changjianing hexo]# hexo n "文章标题" //-----其中 我的家 为文章标题，执行命令 hexo n "我的家" 后会在项目 \hexo\source_posts 中生成 我的家.md文件，用编辑器打开编写即可当然，也可以直接在 \hexo\source\_posts 中新建一个 md 文件，我就是这么做的。 写完后，推送到服务器上，执行以下命令即可在我们的站点看到新的文章。 //如果执行命令: hexo n "文章标题" 出现未找到命令//则需重装Hexo,执行次命令即可: npm install hexo-cli -g 然后执行以下操作 12345[root@changjianing hexo]# pwd/home/changjianing/Downloads/hexo[root@changjianing hexo]# hexo g //生成[root@changjianing hexo]# hexo d //部署 打开自己的主页,即可查看效果 2. 删除文章删除文章的过程一样也很简单，先删除本地文件，然后通过生成和部署命令进而将远程仓库中的文件也一并删除。具体来说，以最开始默认形成的 helloworld.md 这篇文章为例。 首先进入到 /home/changjianing/hexo/source/_post 文件夹中，找到 helloworld.md 文件，在本地直接执行删除 然后执行以下操作: 12[root@changjianing hexo]# hexo g //生成[root@changjianing hexo]# hexo d //部署 然后去主页即可查看效果 五. 参考网址1. 搭建 Hexo 2. 将 Hexo 和 Github Pages 结合 3. 更换 Hexo 主题 和 新建文章 4. 删除文章]]></content>
      <tags>
        <tag>Do what you say,say what you do. 做你说过的，说你能做的</tag>
      </tags>
  </entry>
</search>
