<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基础博弈]]></title>
    <url>%2F2019%2F09%2F08%2F%E5%9F%BA%E7%A1%80%E5%8D%9A%E5%BC%88%2F</url>
    <content type="text"><![CDATA[基础博弈1. 博弈论的简介 博弈论是二人或多人在平等的对局中各自利用对方的策略变换自己的对抗策略，达到取胜目标的理论。博弈论是研究互动决策的理论。博弈可以分析自己与对手的利弊关系，从而确立自己在博弈中的优势，因此有不少博弈理论，可以帮助对弈者分析局势，从而采取相应策略，最终达到取胜的目的。博弈的类型分为：合作博弈、非合作博弈、完全信息博弈、非完全信息博弈、静态博弈、动态博弈，等等。 2. 基础概念 必胜态：通过某一步可以转移到必败态的局面。 也就是说，对于一个处于必胜态的玩家，他总能找到一种合法操作，将当前局面变成一个必败态然后交给对方，如果中途不出现意外的话，最终自己就会得到胜利。但是处于必胜态并不意味着任意的操作都能将当前局面变成必败态。 必败态：通过某一步只能转移到必胜态的局面。 也就是说，处于必败态的玩家无论做什么操作，都只会将当前的局面变成必胜态，然后交给对方，只要对方足够聪明，那么该玩家将输掉比赛。 对于足够聪明的两个博弈者来说，游戏的胜负在比赛前就已经知道(当然，我这里只是说在题目里，在现实中如果是稍微复杂一点的博弈游戏，单凭人脑是很难达到那种水平)，也就是说胜利的一方总能找到胜利的路径，而输掉的那一方无论怎样走，胜利的一方都能找到对应的方法。也就是说先后手以及起始局面可以决定整场博弈的胜负。 3. 巴什博弈（Bash Game） 只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。 求 r=n%(1+m), 判断 r 是否等于 0，如果 r 不等于 0，先手必胜，否则后手必胜。为什么？ 我们可以分析一下，对于 n=(1+m) * r+s，如果 s不等于 0 的话，先手取走s，那么总的物品数剩下 (1+m) * r，然后后手取走 k 的话，先手只要取走 1+m-k 的物品，就可以保持 n=(1+m) 的倍数的局面交给对方，这意味着什么？意味着 n=0 的局面最终会被后手得到，那样后手就输了。而如果s等于0的话，那么对于先手取k的物品，后手只要取 1+m-k 个物品就可以将n=0的局面转给先手，先手就输了。 所以这里的必败态是(1+m)的倍数。有没有发现，对于一场博弈来说，所有的必败态都会有相似的地方，就像这里，必败态一定是(1+m)的倍数。 然后再说深一点的巴什博奕：只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取p个，最多取q个，如果剩下的物品数小于p的话需要一次取完。最后取光者得胜。 这个又怎样求？按照上面的思路，我们可以得到公式n=(p+q)*r+s。 那么这里的s有两种情况①s&gt;=p，②s&lt;p,。 对于①很容易分析，只要先手取走s的话，对于后手去k，先手只要取p+q-k即可保证先手必胜。 对于②，分析起来没有①那么简单，所以这可能就一定需要用后面讲到的用SG值来判断了。 然后在讲一下一个问题。如果条件和基本的巴什博奕基本一样，但是说的是最后谁是无法再取物品的是赢家的话，那该怎么处理呢？ 既然是这样，先手只要判断一下能不能将最后一步留给自己就可以了。而最后一步最少也要保留一个物品，所以我们可以将这个问题转化为基本的巴什博奕，只是终点变成一个物品，而不是零个物品。所以判断的条件是(n-1)%(1+m)!=0 ? 先手赢 : 后手赢。 代码实现 : 1234int Bash_Game(int n,int m) &#123; //是否先手有必赢策略 if (n % (1 + m) != 0) return 1; //先手赢 return 0; //后手赢&#125; 例题:1. HDU1846 (模板题) http://acm.hdu.edu.cn/showproblem.php?pid=1846 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() &#123; int t; cin &gt;&gt; t; while(t--) &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; int s = n % (1 + m); if(s) cout &lt;&lt; "first" &lt;&lt; endl; else cout &lt;&lt; "second" &lt;&lt; endl; &#125; return 0;&#125; 2. HDU4764 (巴什博弈变形) http://acm.hdu.edu.cn/showproblem.php?pid=4764 12345678910111213#include &lt;iostream&gt;using namespace std;int main() &#123; int n, m; while(cin &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m) &#123; int s = (n - 1) % (1 + m); //谁先写到 大于等于n 谁就输 if(s) cout &lt;&lt; "Tang" &lt;&lt; endl; else cout &lt;&lt; "Jiang" &lt;&lt; endl; &#125; return 0;&#125; 4. 尼姆博弈(Nimm Game) 和 扩展 有若干堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 假设这里有n堆物品，每一堆的数量分别是a1,a2,a3,…,an。 那么如果ans = a1^a2^a3^…^an != 0，那么就是先手必胜，否则就是后手必胜。 这里我们需要用到二进制的思想。首先我们用必胜态和必败态的定义来证明一下。 首先，根据题意，只要还有物品，玩家就一定要取，而且每一次操作以后，物品的数目必定会减少。 对于必败态，也就是ans=0，那就说明a1^a2^a3^…^an=0，令a1,a2,a3…,an中，ai为某一堆物品的数量, ai^m=a1^a2^a3…^ai^…^an=0。我们从ai里面取走物品，那么ai–&gt;ai’最终ai’^m必然不等于零，即转为必胜态，符合必败态的定义。(感觉证明不算很严谨······) 对于必胜态，如果此时的状态为aj^p=q(p等于除了aj以外的其他a[]的异或和)，假设我们从aj上面取一定数目的物品使得aj–&gt;aj’，最终使aj’^p = 0的话，那么我们可以得到： aj’^p^q=q —&gt; aj^aj’^p^p=q —&gt; aj^aj’=q —&gt; aj^aj’^q=0 这意味着什么，因为我们是从aj那里取走一定的物品以后变成aj’的，这里取走的个数可能有很多种方法，但是，如果我们取走的个数是二的次幂这么多呢？很明显q就是我们需要从aj上面取走的个数了。只要当前的玩家从某一堆物品个数比q大的堆上取走q个物品，那么就可以将当前状态转化为必败态，并且转给对方。所以要保证先手必胜的条件就是a1^a2^a3^!123456789101112**代码实现:**```c++int Nimm_Game(int n) &#123; //假设n个数存在数组f[]中,有必胜策略返回1 int flag = 0; for(int i = 1; i &lt;= n; i++) &#123; flag ^= f[i]; &#125; if(flag) return 1; //先手赢 return 0; //后手赢&#125; 例题:1. 洛谷 P2197 (尼姆博弈 模板) https://www.luogu.org/problem/P2197 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main() &#123; int t; cin &gt;&gt; t; while(t--) &#123; int n, x, ans = 0;; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; x; ans ^= x; &#125; if(ans) cout &lt;&lt; "Yes" &lt;&lt; endl; else cout &lt;&lt; "No" &lt;&lt; endl; &#125; return 0;&#125; 扩展: 求 第一次/每次 取出的数量 123456789101112131415161718192021// 第一次从b堆中取出a个这个游戏的SG值就是各堆数量的异或和，当 SG 为 0 时先手必败，否则先手就要把SG变为0先检验 SG 值，如果是 0 输出 lose，否则我们按照以下原则行动--//----重点来了------有 n 个数的异或值不为 0 现在要减少一个数使异或值为 0假设 n 个数：a1 ,a2,a3...ana1^a2^a3^..^an=k那么我们可以对一个数进行操作,假设这个数是a1，设 a1^k = a'， a'^a2^a3^...^an = a1^a2^a3^...^an^k = k^k = 0;所以我们只需要从头到尾检验每个数异或k的值是否比它小(因为是要减少)，遇到小的直接输出 ai-ai^k 即可//在这里要明白: 假设把每堆石子的数量异或以后得到数为 k (k!=0) 这里 k 并不是第一次要取出 k 个石子 在这里设用 k 去与每堆f[i]异或得到的一个数为 m 若 m &lt; f[i], 则说明第一次是在 第i堆中取了f[i]-k^f[i]个石子 例题:1. 洛谷 P1427 (第一次取出) https://www.luogu.org/problem/P1247 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt; using namespace std;int n;int k[500005];int main() &#123; int ans = 0; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; k[i]; ans ^= k[i]; &#125; if(!ans) &#123; cout &lt;&lt; "lose" &lt;&lt; endl; return 0; &#125; for(int i = 1; i &lt;= n; i++) &#123; if((ans ^ k[i]) &gt;= k[i]) continue; cout &lt;&lt; k[i] - (ans ^ k[i]) &lt;&lt; ' '&lt;&lt; i &lt;&lt; endl; k[i] ^= ans; break; &#125; for(int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; k[i] &lt;&lt; ' '; &#125; cout &lt;&lt; endl; return 0;&#125; 2. HDU 2176 (每次 取出/剩余 ) http://acm.hdu.edu.cn/showproblem.php?pid=2176 12345678910111213141516171819202122232425262728#include &lt;iostream&gt; using namespace std;int n;int k[500005];int main() &#123; while(cin &gt;&gt; n &amp;&amp; n) &#123; int ans = 0; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; k[i]; ans ^= k[i]; &#125; if(!ans) &#123; cout &lt;&lt; "No" &lt;&lt; endl; continue; &#125; cout &lt;&lt; "Yes" &lt;&lt; endl; for(int i = 1; i &lt;= n; i++) &#123; if((ans ^ k[i]) &gt;= k[i]) continue; int t = ans ^ k[i]; //t是按照最优的方法取完石子后，剩下的石子 cout &lt;&lt; k[i] &lt;&lt; ' '&lt;&lt; t &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
